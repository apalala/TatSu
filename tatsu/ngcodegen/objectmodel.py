import inspect
import re
from collections import namedtuple

from .. import grammars, objectmodel
from ..exceptions import CodegenError
from ..mixins.indent import IndentPrintMixin
from ..util import safe_name, compress_seq
from ..walkers import NodeWalker


HEADER = """\
    #!/usr/bin/env python3

    # WARNING: CAVEAT UTILITOR
    #
    # This file was automatically generated by TatSu.
    #
    #    https://pypi.python.org/pypi/tatsu/
    #
    # Any changes you make to it will be overwritten the next time
    # the file is generated.

    from __future__ import annotations

    from typing import Any
    from dataclasses import dataclass

    from tatsu.semantics import ModelBuilderSemantics
    {base_type_import}


    @dataclass(eq=False)
    class {name}ModelBase({base_type}):
        pass


    class {name}ModelBuilderSemantics(ModelBuilderSemantics):
        def __init__(self, context=None, types=None):
            types = [
                t for t in globals().values()
                if type(t) is type and issubclass(t, {name}ModelBase)
            ] + (types or [])
            super().__init__(context=context, types=types)
"""


TypeSpec = namedtuple('TypeSpec', ['class_name', 'base'])


def codegen(model: grammars.Model, parser_name: str = '', base_type: type = objectmodel.Node) -> str:
    generator = PythonModelGenerator(parser_name=parser_name, base_type=base_type)
    generator.walk(model)
    return generator.printed_text()


class PythonModelGenerator(IndentPrintMixin, NodeWalker):

    def __init__(self, parser_name: str = '', base_type: type = objectmodel.Node):
        super().__init__()
        self.base_type = base_type
        self.parser_name = parser_name or None

    def walk_Grammar(self, grammar: grammars.Grammar):
        base_type_qual = self.base_type.__module__
        base_type_import = f'from {self.base_type.__module__} import {self.base_type.__name__.split('.')[-1]}'

        self.parser_name = self.parser_name or grammar.name
        self.print(
            HEADER.format(
                name=self.parser_name,
                base_type=self.base_type.__name__,
                base_type_import=base_type_import,
            )
        )
        self.print()
        self.print()

        rule_index = {rule.name: rule for rule in grammar.rules}
        rule_specs = {
            rule.name: self._type_specs(rule)
            for rule in grammar.rules
        }

        model_classes = {s.class_name for spec in rule_specs.values() for s in spec}
        base_classes = {s.base for spec in rule_specs.values() for s in spec}
        base_classes -= model_classes
        # raise Exception('HERE', base_classes, model_classes)

    def walk_Rule(self, rule: grammars.Rule):
        specs = self._type_specs(rule)
        if not specs:
            return

        arguments = sorted({safe_name(d) for d, _ in compress_seq(rule.defines())})

        self.print()
        self.print()

        node_spec = specs[0]
        base_specs = list(reversed(specs[1:]))
        base = base_specs and base_specs[0] or f'{self.parser_name}ModelBase'
        self.print(f'class {node_spec.class_name}({base}):')

        with self.indent():
            if not arguments:
                self.print('pass')
            for arg in arguments:
                self.print(f'{arg}: Any = None')

    def _type_specs(self, rule: grammars.Rule) -> TypeSpec:
        if not self._get_node_class_name(rule):
            return []

        spec = rule.params[0].split('::')
        class_names = [safe_name(n) for n in spec] + [f'{self.parser_name}ModelBase']

        typespec = []
        for i, class_name in enumerate(class_names[:-1]):
            base = class_names[i + 1]
            typespec.append(TypeSpec(class_name, base))

        return typespec

    @staticmethod
    def _get_node_class_name(rule: grammars.Rule):
        if not rule.params:
            return None

        node_names = rule.params[0]
        if not isinstance(node_names, str):
            return None
        if not re.match(r'\w+(?:::\w+)*', node_names):
            return None
        if not node_names[0].isupper():
            return None
        return node_names
